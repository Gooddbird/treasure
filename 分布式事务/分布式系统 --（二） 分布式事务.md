# 从单机事务到分布式事务
说分布式事务之前，先提一下单机事务。**事务**是作后端开发人员几乎必须掌握的一个点，当然这里说的是狭义上的数据库的事务。

在 MySQL 章节中，介绍过单机事务。单机事务具有 ACID 特性:
- Atomicity(原子性)：原子性代表事务中的操作，要么全部执行成功，要么全部都不执行。
- Consistency(一致性): 指数据库必须从一个正确的状态迁移到另一个正确的状态。
- Isolation(隔离性): 并发执行多个事务时，各个事务之间互不干扰。
- Durability(持久性): 事务执行完后，数据不会丢失。

随着微服务、分布式等技术的兴起，一个系统被拆分成立多个微服务，他们共同组成了分布式系统架构。在分布式系统下，单机事务已经无法足以满足我们的需求了。

例如支付系统常见的转账服务，最开始他只有一个转账服务。所有资源公用一个 DB：

![](imgs/2-1-%E5%8D%95DB%E6%9E%B6%E6%9E%84.drawio.png)


现场景为用户 A 转账给用户 B 100元，在这个过程中，我们要做三件事：
```
1. 账户生成一笔转账单，状态 State 为初始态。并且锁定这笔单，防止并发导致数据异常。
2. A 账户扣除 100 元
3. B 账户增加 100 元
4. 转账成功，转账单状态 State 置为成功，解锁转账单。
```

如果是单机事务，可以很容易完成上面的操作，直接使用 MySQL 开启一个事务即可。

然而事实很残酷，由于用户量大、单机性能受限、DB受限等原因，对以上架构做了拆分。首先账户资源的 DB 跟转账单据的 DB 做了拆分，同时账户操作拆分为独立微服务，系统架构如下：

![](imgs/2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84.drawio.png)

此时转账需要完成这些操作：
```
1. 转账服务生成一笔转账单，状态 State 为初始态。并且锁定这笔单，防止并发导致数据异常。
2. 转账服务调用账户服务，请求 A 账户扣除 100 元
3. 转账服务调用账户服务，请求 B 账户增加 100 元
4. 转账成功，转账服务将转账单状态 State 置为成功，解锁转账单。
```

由于 DB、服务之间都做了拆分，此时的事务横跨了多个服务，多个DB资源，原本能直接在当前DB执行的操作，现在变成了调用其他服务的接口来实现，这就是分布式事务。

而假设上面场景中，A账户扣除余额失败怎么办？A账户扣除余额成功，但是B账户增加余额失败怎么办？分布式事务同样满足原子性、一致性。

可见，分布式事务的实现，就没法像单机事务那么简单了。显然，你没法保证每个子事务都能执行成功，为此需要设计一些补偿、逆向等流程来确保分布式事务正常执行。

下面将介绍一些分布式事务的解决方案

# 2PC
2PC 是非常经典的分布式事务解法方案之一，虽然现实生产环境中基本不用到单纯的2PC，但了解它的思想是很重要的，其他的解决方案多多少少跟2PC也有很大的相关性。

## XA 协议
在说 2PC 之前，先介绍一个概念。XA 协议是由 X/Open 组织提出的一种分布式事务处理规范，也叫 DTP（Distributed Transaction Processing）模型，他把分布式事务的参与者划分为：
- AP：AP即应用程序，即需要操作资源的业务方，例如上例中的转账服务，他就是一个 AP。
- RM：RM即资源管理器，例如上例中的 DB 就属于RM。
- TM：TM即事务管理器，它是整个完成分布式事务的核心，用来协调整个分布式事务。

而XA协议则是规定了 TM 与 RM 的通信规范。

## 2PC 概述
XA协议使用 2PC 完成分布式事务，2PC （二阶段提交），它整个通信过程如下：

